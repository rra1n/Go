# kmp算法
kmp 算法是字符串匹配的一种算法，能够做到线性的时间复杂度

kmp算法在遇到某个字符串不匹配时，会根据 __next数组__ 回溯到某个位置，从这个位置开始进行匹配。

## next 数组的含义

__next数组__ 记录的是每个字符的最长前后缀相等的长度，例如，ababa
| a | b | a | b | a | a | 
|-|-|-|-|-|-|
|-1|0|0|1|2|3|

$next[i]$ 记录的是模式串中 __不包括__ $s[i]$ 的最大相等前后缀长度

## next数组的求解过程
我们规定 $next[0] = -1, next[1] = 0$

如果模式串当前的位置 $i$ 和 $i$ 的前一个位置 $j$ 的 $next[j]$ 是相同的，那么
```
next[i] = next[j] + 1
```
否则我们继续回溯 $next$，知道找到或者 $next[j] = -1$ 为止

## kmp算法的匹配过程:

> 例如有一个主串 $s$ 和一个模式串 $t$ ，当主串的 $i$ 位置和模式串的 $j$ 位置不匹配的时，模式串和主串不是暴力的从头开始匹配，而是根据 $next$ 数组的值，使得 $j = next[j]$ 然后让 $s[i]$ 和 $t[j]$ 开始进行匹配。


假设我们的主串是 $abababaa$ 当我们的模式串 $t$ 和主串 $s$ 第一次发生不匹配时，此时主串指向 $abababaa$ 的倒数第三个，也就是 $b$ ，此时我们会根据next数组，使得当前的 $b$ 和模式串的第三个位置进行匹配，也就是因为 $next[i] = 3$，直到模式串被全部匹配完

## kmp算法的原理
kmp算法借助了 __最长相等前后缀数组__ 。当发生失配的时候，假设主串当前位置为 $i$ , 模式串的位置为 $j$ ，同时 $next[j] = k$ ，也就是在当前的失配位置，__模式串 $t$ 的 $0到k-1$ 和 $j-k到j-1$ 是相同的__ ，而我们的主串是在 $i$ 位置产生失配的，也就是说，主串的 $i-2-k到i-1$ 和 模式串的 $j-k到j-1$ 是相同的，而根据 “模式串 $t$ 的 $0到k-1$ 和 $j-k到j-1$ 是相同的”，我们知道模式串的 $0到k-1$ 和主串的 $i-2-k到i-1$ 是相同的，于是我们可以直接从模式串 $t[k-1]$ 的下一个位置，也就是 $t[k]$ 与当前的失配位置 $s[i]$ 进行匹配 

代码如下
``` go
func getNext(t string) []int {
    m, i, j := len(t), 0, -1
    next := make([]int, m)
    next[0] = -1
    for i < m-1 {
        if j == -1 || t[i] == t[j] {
            i++
            j++
            next[i] = j
        } else {
            j = next[j]
        }
    }
    return next
}

func kmp(s, t string) bool {
    next := getNext(t)
    n, m, i, j := len(s), len(t), 0, 0
    for i < n && j < m {
        if j == -1 || s[i] == t[j] {
            i++
            j++
        } else {
            j = next[j]
        }
    }
    return j == m
}
```