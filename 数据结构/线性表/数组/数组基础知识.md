# 数组的定义
数组占据的是系统内连续的空间
```
package main

import "fmt"

func main() {
	n := 10
	b := make([]int, n)
	for i := 0; i < n; i++ {
		fmt.Printf("数组中下标为%d的数的内存地址是%d", i, &b[i])
		fmt.Println()
	}
}
```

输出结果为

```
数组中下标为0的数的内存地址是824634384544
数组中下标为1的数的内存地址是824634384552
数组中下标为2的数的内存地址是824634384560
数组中下标为3的数的内存地址是824634384568
数组中下标为4的数的内存地址是824634384576
数组中下标为5的数的内存地址是824634384584
数组中下标为6的数的内存地址是824634384592
数组中下标为7的数的内存地址是824634384600
数组中下标为8的数的内存地址是824634384608
数组中下标为9的数的内存地址是824634384616
```

计算机按字节编址一个 $int$ 类型占 $8B$

# 数组的声明
```
func main() {
	n := 10
	a := []int{}
	b := make([]int, n)
}
```
对数组 $a$ 的声明实际上是声明了一个空数组，而对 $b$ 数组的声明则是声明了一个长度为 $10$ 的数组，默认下， $Go$ 语言会对这些位置填充 $0$ 。

因此执行下列语句时：
```
package main

import "fmt"

func main() {
	n := 10
	a := []int{}
	b := make([]int, n)
	fmt.Println(a[0]) // 报错
	fmt.Println(b[0]) // 0
}
```
# 数组的相关方法

## Append 方法

```
a = append(arr, ele)
``` 

要求你传入两个参数，第一个参数是一个切片，第二个参数是元素，会将 $ele$ 中的元素加入到 $arr$ 的末尾中，并且将结果赋给 $a$ 数组。如果想要把元素加入到数组 $arr$ 的前面，可以执行下面的代码

```
a = append([]int{ele}, arr...)
```

将原来的数组 $arr$ 展开，然后将其所有元素加入到 $ele$ 单个元素变成的数组中，然后把这个新组成的数组赋个$a$，相当于把 $ele$ 加入到了 $arr$ 的前面。

具体看下列代码：

```
package main

import "fmt"

func main() {
	n := 10
	a := make([]int, n)
	for i := 0; i < n; i++ {
		a[i] = i + 1
	}
	a = append(a, 3)             // 在数组的后面加入元素
	a = append([]int{100}, a...) // 在数组的前面加入元素
	for i := len(a) - 1; i >= 0; i-- {
		fmt.Printf("%d ", a[i])
	}
}

```

执行结果如下：

```
3 10 9 8 7 6 5 4 3 2 1 100 
```

## 下标获取元素和切片

 $Go$ 切片会直接引用原数组中的数据，他并不是对原来数组的复制，对切片的修改会直接改变原来数组的值

```
package main

import "fmt"

func main() {
	n := 10
	a := make([]int, n)
	for i := 0; i < n; i++ {
		a[i] = i + 1
	}
	fmt.Println("切皮执行前:")
	for i := 0; i < n; i++ {
		fmt.Printf("%d ", a[i])
	}
	fmt.Println()
	b := a[0:3]
	a[2] = 1
	fmt.Println("切片后：")
	fmt.Println(b)
	fmt.Println("改变切片后原数组变为：")
	for i := 0; i < n; i++ {
		fmt.Printf("%d ", a[i])
	}
}

```

执行结果为：

```
切皮执行前:
1 2 3 4 5 6 7 8 9 10
切片后：
[1 2 1]
改变切片后原数组变为：
1 2 1 4 5 6 7 8 9 10
```

## 数组的复制与引用

在 $Go$ 中，数组的 __复制__ 需要使用 $copy()$ 函数，内部接受两个变量，一个是复制到的对象$a$，另一个是被复制的对象 $b$, $a$ 的长度需要和 $b$ 的长度一致，否则会报错。

对复制的对象，修改其内部的值不会影响被复制的对象，因为其不是对对象 $b$ 的引用。

如果声明另一个对象 $c$ ，使得 $c=a$ ，那么对对象 $c$ 内部值的修改会影响到 $a$ 内部的值。

```
package main

import "fmt"

func main() {
	n := 10
	a := make([]int, n)
	for i := 0; i < n; i++ {
		a[i] = i + 1
	}
	b := make([]int, n)
	copy(b, a)
	b[0] = 1000
	fmt.Printf("修改复制对象b后,原对象a的值:%d ", a[0])
	fmt.Println()
	c := a
	c[0] = 10000
	fmt.Printf("用c引用a并且修改c后，原对象的值:%d ", a[0])
}

```

执行结果如下：

```
修改复制对b后，原对象a的值:1 
用c引用a并且修改c后，原对象的值:10000
```

# 二维数组的定义
这里只将怎么动态定义二维数组。

```
package main

import "fmt"

func main() {
	n, m := 3, 4
	g := make([][]int, n)
	for i := 0; i < n; i++ {
		g[i] = make([]int, m)
	}
	x := 1
	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			g[i][j] = x
			x++
		}
	}
	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			fmt.Printf("%d ", g[i][j])
		}
		fmt.Println()
	}
}
```

执行代码后结果如下：

```
1 2 3 4 
5 6 7 8
9 10 11 12
```

